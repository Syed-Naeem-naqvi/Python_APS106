##############################
# APS106 Winter 2022 - Lab 4 #
##############################

import math

def heat_control_hysteresis_thresh(temp_measured, current_state, temp_desired, alpha):
    """
    (float, bool, float, float) -> bool
    
    Implement a hysteresis threshold to determine and return the
    next state of the heater using the current state, latest measurement,
    desired temperature, and hyteresis buffer range (+/- alpha). 
    
    >>> heat_control_hysteresis_thresh(33.2, True, 40.0, 5.0)
    True
    
    >>> heat_control_hysteresis_thresh(28.4, True, 27.5, 1.0)
    True
    
    >>> heat_control_hysteresis_thresh(50.6, True, 40.0, 10.0)
    False
    
    >>> heat_control_hysteresis_thresh(30.8, False, 40.0, 2.9)
    True
    """    
    
    # TODO Write your code here
    if abs(temp_measured - temp_desired) <= alpha:
        return current_state
    elif temp_measured < (temp_desired - alpha):
        return True
    elif temp_measured > (temp_desired + alpha):
        return False
        

def newton_raphson_sqrt(n, epsilon):
    """
    (float,float) -> float
    
    Calcualtes the square root of a number, n, using the Newton-Raphson method.
    Returned value is the square root of n within tolerance amount
    specified by epsilon.
    
    >>> newton_raphson_sqrt(4.0,0.001)
    2.0
    
    >>> newton_raphson_sqrt(2.0, 0.1)
    1.417

    """
    
    # TODO Write your code here
    
    x = n
    while abs(pow(x, 2) - n) > epsilon :
        x = 0.5*(x + (n/x))
    return round(x,3)


def get_sensor_measurement(t,c0,c1,c2,c3,c4):
    """
    (float,float,float,float,float,float) -> float
    
    Simulates a sensor value reading. The value returned by the 
    function is generated by from the following equation:
        
        s(t) = c0*t + c1*sqrt(t) + c2*sin(t) + c3*cos(8t) + c4
        
    where t, c0, c1, c2, c3, and c4 are parameters passed into the function.
    The returned value is rounded to 3 decimal points.
    
    DO NOT EDIT THIS FUNCTION
    """
    measurement = c0*t + c1*newton_raphson_sqrt(abs(t),0.0005) + c2*math.sin(t) + c3*math.cos(8*t) + c4
    return round(measurement,3)


def thresh_crossing_counter(temp_desired, hyst_alpha,
                            t_start,t_stop,
                            c0,c1,c2,c3,c4):
    """
    (float, float, float, float, float, float, float, float, float) -> int
    
    Counts the number of times a simulated sensor measurement crosses a 
    hysteresis threshold.
    
    >>> thresh_crossing_counter(0.0, 0.2, 0.0, 10.01, -0.1, 2.0, 10.0, -5.0, -1.0)
    10
    """
    t_step = 0.05 # amount to increment the time after each sensor reading
    
    # Initialize the state
    # simply compare to the desired temperature because we don't yet know
    # the current state to use the hysteresis threshold
    state = get_sensor_measurement(t_start,c0,c1,c2,c3,c4) <= temp_desired 
    
    # TODO Write your code to complete the function here
    
    total = 0 
    initial_state = temp_desired < state
    while t_start <= t_stop:
        temp_state = get_sensor_measurement(t_start, c0, c1, c2, c3, c4) 
        state2 = heat_control_hysteresis_thresh(temp_state, initial_state, temp_desired, hyst_alpha)
        if state2 != initial_state:
            total += 1
            initial_state = state2
        t_start += t_step
    
    return total


if __name__ == '__main__':
    import doctest
    doctest.testmod()

print(thresh_crossing_counter(0.0, 0.2, 0.0, 10.01, -0.1, 2.0, 10.0, -5.0, -1.0))

